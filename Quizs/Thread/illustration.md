## 目录
* [运行结果](#运行结果)
* [解释说明](#解释说明)
* [参考资料](#参考资料)
* [调试中遇到的问题的小结](#调试中遇到的问题的小结)
___
#运行结果
### 对ThreadSafeDemo1的测试 ###
	输出随机数-1521077258
	输出随机数395218550
	循环次数10
	循环次数0

### 对ThreadSafeDemo2和ThreadSafeDemo3的测试 ###
	加入元素后list容量1
	加入元素后list容量2
	加入元素后list容量3
	加入元素后list容量4
	加入元素后list容量5
	加入元素后list容量6
	加入元素后list容量7
	移除后容器6
	移除后容器5
	移除后容器4
	移除后容器3
	移除后容器2
	移除后容器1
	移除后容器0
	加入元素后list容量1
	加入元素后list容量2
	加入元素后list容量3
	加入元素后list容量4
	加入元素后list容量5
	加入元素后list容量6
	加入元素后list容量7
	移除后容器6
	移除后容器5
	移除后容器4
	移除后容器3
	移除后容器2
	移除后容器1
	移除后容器0
	加入元素后list容量1
	加入元素后list容量2
	加入元素后list容量3
	加入元素后list容量4
	加入元素后list容量5
	加入元素后list容量6
	加入元素后list容量7
	移除后容器6
	移除后容器5
	移除后容器4
	移除后容器3
	移除后容器2
	移除后容器1
	移除后容器0
	加入元素后list容量1
	加入元素后list容量2
	加入元素后list容量3
	加入元素后list容量4
	加入元素后list容量5
	加入元素后list容量6
	加入元素后list容量7
	移除后容器6
	......（无限重复直到暂停）
# 解释说明
* ThreadSafeDemo1类</br>
测试同步代码块的机制。run()内被锁住的list只能有一个线程执行，当一个线程把list容器的容量全部清空后，第二个线程获取锁的时候list的容量为0。
***
* ThreadSafeDemo2类</br>
给容器增加容量。当获取锁时执行while语句，如果容器容量大于6，此线程wait()并释放锁。当容器容量为5时，唤醒等待的另一个线程，使之处于可运行状态，等待CPU分配资源。
***
* ThreadSafeDemo3类</br>
给容器减少容量。当获取锁时执行while语句，如果容器容量小于等于0，此线程wait()并释放锁。当容器容量为1时，唤醒等待的另一个线程，使之处于可运行状态，等待CPU分配资源。
***
* ThreadMain类</br>
入口函数类,测试线程1的同步代码块的机制（同时只能有一个线程对list进行操作）；线程2、3的相互作用（一个线程让容器容量增加到7，一个线程让容器容量减小到0；无限循环）
***
# 参考资料
[wait与notify的异常产生原因](https://blog.csdn.net/lhd201006/article/details/50986016 "参考链接")

[java线程的状态转换](https://my.oschina.net/mingdongcheng/blog/139263 "参考链接")

[TimeUnit类中的sleep与线程的sleep的对比](http://www.importnew.com/7219.html '参考链接')

[wait状态的理解](https://my.oschina.net/goldenshaw/blog/802620 '参考链接')


[时间片](https://zhidao.baidu.com/question/18757048.html '参考链接')
***
# 调试中遇到的问题的小结
java线程被创建时，如果不分配优先级，会被默认分配为5（线程优先级范围1-10 java中数字越大优先级越高，但是若物理操作系统优先级数目少于java的优先级的数目，java中的某两个或多个优先级在系统中对应同样的优先级）。系统对相同优先级的线程采用```时间片```方法轮流分配处理机，但并不是在所有的系统中运行java程序时都采用时间片策略调度程序。

执行wait()后，wait()后面的语句都不执行，线程处于等待状态，等待与该线程相同对象的notify()

wait与notify需要与synchronized关键字搭配
